# PLANMING
- Purpose: deliver a KISS, Docker-first prototype that surfaces Salesforce research, analysis, and recommendations in a chat-like canvas while respecting three explicit user roles (Admin, Employee, Guest).
- Architecture constraints: reuse the existing FastAPI (`reranker`) + Next.js (`next-rag-app`) stack, keep all services orchestrated through Docker Compose (`make install`, `make up`, `docker-compose.yml`), and rely on the chat endpoints already exposed by the backend.
- Layout intent: design a single cohesive workspace that pairs the conversation canvas (research + recommendation view) with utility panes (role-aware sidebar, context drawer, tone controls, admin actions/tools strip). Each card/tab must reference backend data:
  1. **Conversation Canvas** – renders research, analysis, and action recommendations fetched through the chat API (`/api/chat` or existing conversation endpoints). Show annotated Salesforce case details, signal severity, and surface next-best steps.
  2. **Role-aware Sidebar** – highlights current identity (via `/api/auth/me`) and role-specific navigation, plus Admin controls that can fetch `/api/admin/users` when elevated. Roles (Admin, Employee, Guest) determine which actions (regenerate/tweak/export) are enabled.
  3. **Context Drawer** – surfaces system prompts, citation links, or memory excerpts retrieved via chat metadata; reuse stored references, note which ones came from the Salesforce knowledge base, and keep content short so the drawer is scannable.
  4. **Tone/Persona Controls** – slider or button group to shift between persona (friendly, concise, formal) and tone (research, directive). Persist selections in component state before propagating to chat API calls (include selected tone in request payloads so backend logging can adapt).
  5. **Admin Actions Panel + Tools Strip** – reuse `/api/chat` metadata for “Regenerate” and “Tweak Prompt”; call backend helpers (or implement new ones) to capture exports (`Export Answer`) and align with `/api/auth` tooling (e.g., verifying the current Admin token before running heavy operations). Include quick-access tools (similar to ChatGPT’s Tools strip) that hit `/api/admin/users`, `/api/auth/me`, and the chat endpoint to keep metrics up to date.
- Best practices baked into planning:
  * Keep it simple: avoid reinventing mechanisms already provided by `next-rag-app`; reuse existing components and data models whenever possible.
  * Type safety + docs: follow project conventions (Google-style docstrings, type hints, config imports from `config.py`, avoid bare `except` blocks).
  * Config-driven: read environment values exclusively via `config.py` and keep Docker env in `.env`/Compose files.
  * Testing-as-you-go: after each meaningful change, run `make test` (or focused `pytest` targets) and `pre-commit run --all-files` to catch lint/type/security issues.
  * Docker-first workflow: every new service/component must work when launching `docker-compose`/`make up`. Don’t rely on local-only binaries; prefer containers or scripts that already run inside the stack.

# TASK
- Task 1: Capture the current API contracts within `reranker` and `next-rag-app`, then document how the new UI components consume those endpoints (`/api/auth/me`, `/api/admin/users`, chat/conversation endpoints, any existing system prompt routes). Note whether new backend helpers are required (e.g., summarizing Salesforce case metadata) or if middleware can repurpose current responses.
- Task 2: Sketch the component layout for the prototype (cards/tabs in `next-rag-app`), including data flows between sidebar, canvas, drawer, and admin panel. Annotate how each component updates state, persists tone/persona selections, and triggers backend calls (Chat API for research text, `/api/admin/users` for Admin capabilities).
- Task 3: Implement frontend wiring in `next-rag-app` using reusable components (or new ones if necessary) while keeping logic simple. Ensure Docker integration by running `make install` to install Node/Python dependencies, then `make up` or `docker-compose up` to validate the UI and backend operate together.
- Task 4: Create QA/validation checks that prove the prototype ships working research/recommendation flows (e.g., `make test`, targeted `pytest tests/...`, or Next.js smoke tests). Outline how to manually test Docker services (a quick `curl` to `/api/auth/me` inside the container) so we can verify each role’s permissions quickly.
- Task 5: Document the best-practice playbook alongside the prototype (e.g., include tech debt notes in `docs/PROTOTYPE_PLAN.md` or `docs/README.md`) so future contributors know to prefer config imports, avoid hardcoded secrets, and soil the code with tests after every change.

# TODO
- Todo 1: Wire the conversation canvas to the chat system. Define the research/analysis/recommendation data contract (fields like `case_id`, `insight`, `recommendation`, `confidence`, `source_link`). Store tone/persona selections and include them in every chat request payload.
- Todo 2: Build the role-aware sidebar component. Use `/api/auth/me` to identify the authenticated role and conditionally show Admin-only controls (Regenerate, Tweak Prompt, Export). If Admin, call `/api/admin/users` periodically to refresh user lists and show user stats.
- Todo 3: Implement the context drawer view that fetches system prompts or memory entries (possibly from the chat payload's metadata). Show citations referencing Salesforce knowledge (e.g., `case_id` linking to the CRM entry). Keep the drawer accessible via a clear icon/button so users can reopen references quickly.
- Todo 4: Introduce tone/persona controls tied to state. Provide presets (concise, analytical, directive) that fine-tune the chat payload; log tone choices for analytics and include in exported answers for traceability.
- Todo 5: Build the admin actions panel with action buttons wired to `/api/chat/regenerate`, `/api/chat/tweak`, and `/api/chat/export`. Keep the action responses simple, storing results in local state and showing retries/alerts that follow the repo’s alerting patterns.
- Todo 6: Ensure the entire stack is Docker-ready: update Compose files or scripts if necessary so the new UI components and backend endpoints spin up via `make up`. Add smoke checks (e.g., `curl http://localhost:3000/api/chat/health`) to every Dockerized launch.
- Todo 7: Continuously test each change: run `make test`, `pre-commit run --all-files`, and targeted Next.js checks (e.g., `npm run lint` inside `next-rag-app`) before committing. Capture test failures and remedy them before moving to the next TODO item.
- Todo 8: Record the prototype status and next steps in DOCS (e.g., update `docs/PROTOTYPE_PLAN.md` and `docs/README.md`), include testing outcomes, and list any outstanding work requiring more time.
