"""Ring 2 bootstrap: OCR functionality tests.

These tests validate the perform_image_ocr function with proper mocking of 
pytesseract and PIL dependencies. Tests include noise filtering, page number 
extraction, and error handling. They are NOT yet part of enforced coverage gating.

Run standalone (without coverage gate) via:
    pytest tests/test_pdf_processor_ocr.py --no-cov
"""

import os
from unittest.mock import Mock, patch, mock_open

import pytest

from pdf_processor.pdf_utils import perform_image_ocr


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_success(mock_image, mock_pytesseract):
    """Test successful OCR on clean image with good text."""
    # Mock PIL Image
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    # Mock tesseract output
    mock_pytesseract.image_to_string.return_value = "This is clean OCR text.\nSecond line of text."
    
    image_paths = ["/tmp/doc_page1_img1.png"]
    result = perform_image_ocr(image_paths)
    
    assert len(result) == 1
    chunk = result[0]
    assert chunk['text'] == "This is clean OCR text.\nSecond line of text."
    assert chunk['metadata']['type'] == 'image_ocr'
    assert chunk['metadata']['source_image'] == "/tmp/doc_page1_img1.png"
    assert chunk['metadata']['ocr_engine'] == 'tesseract'
    assert chunk['page_number'] == 1  # Extracted from filename
    assert chunk['chunk_type'] == 'image_ocr'


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_noise_filtering(mock_image, mock_pytesseract):
    """Test OCR noise filtering removes symbol-heavy lines."""
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    # Mock noisy tesseract output
    noisy_text = """Good text line here.
++++++++++++++++
Another good line.
===_____===___===
--------
Final good line."""
    
    mock_pytesseract.image_to_string.return_value = noisy_text
    
    result = perform_image_ocr(["/tmp/test.png"])
    
    assert len(result) == 1
    cleaned_text = result[0]['text']
    
    # Should keep good lines
    assert "Good text line here." in cleaned_text
    assert "Another good line." in cleaned_text
    assert "Final good line." in cleaned_text
    
    # Should remove noise lines
    assert "++++++++++++++++" not in cleaned_text
    assert "===_____===___===" not in cleaned_text
    assert "--------" not in cleaned_text


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_low_alphanumeric_density(mock_image, mock_pytesseract):
    """Test OCR filters out lines with low alphanumeric density."""
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    # Mock text with low alphanumeric density
    noisy_text = """Good alphanumeric content here.
!@#$%^&*()_+{}|:"<>?[]\\;',./ symbols only here very long line
Another good line with normal text."""
    
    mock_pytesseract.image_to_string.return_value = noisy_text
    
    result = perform_image_ocr(["/tmp/test.png"])
    
    cleaned_text = result[0]['text']
    
    # Should keep good lines
    assert "Good alphanumeric content here." in cleaned_text
    assert "Another good line with normal text." in cleaned_text
    
    # Should remove line with low alphanumeric density
    assert "symbols only here very long line" not in cleaned_text


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_page_number_extraction(mock_image, mock_pytesseract):
    """Test page number extraction from filename patterns."""
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    mock_pytesseract.image_to_string.return_value = "Test text."
    
    # Test various filename patterns
    test_cases = [
        ("/path/doc_page5_img1.png", 5),
        ("/path/report_page123_img2.jpg", 123),
        ("/path/PAGE10_IMG1.PNG", 10),  # Case insensitive
        ("/path/no_page_pattern.png", 0),  # No pattern, default to 0
        ("/path/page_invalid_img1.png", 0),  # Invalid page number
    ]
    
    for img_path, expected_page in test_cases:
        result = perform_image_ocr([img_path])
        assert len(result) == 1
        assert result[0]['page_number'] == expected_page


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_multiple_images(mock_image, mock_pytesseract):
    """Test OCR on multiple images."""
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    # Different OCR results for each image
    mock_pytesseract.image_to_string.side_effect = [
        "First image text.",
        "Second image content here.",
        "Third image result."
    ]
    
    image_paths = [
        "/tmp/doc_page1_img1.png",
        "/tmp/doc_page2_img1.png", 
        "/tmp/doc_page3_img1.png"
    ]
    
    result = perform_image_ocr(image_paths)
    
    assert len(result) == 3
    assert result[0]['text'] == "First image text."
    assert result[1]['text'] == "Second image content here."
    assert result[2]['text'] == "Third image result."
    
    # Check page numbers
    assert result[0]['page_number'] == 1
    assert result[1]['page_number'] == 2
    assert result[2]['page_number'] == 3


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_empty_text(mock_image, mock_pytesseract):
    """Test OCR skips images with no text."""
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    mock_pytesseract.image_to_string.return_value = ""  # No text
    
    result = perform_image_ocr(["/tmp/empty.png"])
    
    assert result == []  # Should skip empty OCR results


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_very_short_text(mock_image, mock_pytesseract):
    """Test OCR filters out very short text (< 8 chars after cleaning)."""
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    # Text that becomes too short after cleaning 
    mock_pytesseract.image_to_string.return_value = "AB\n++++\n--"
    
    result = perform_image_ocr(["/tmp/short.png"])
    
    assert result == []  # Should skip very short results


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_image_open_error(mock_image, mock_pytesseract):
    """Test OCR handles image opening errors gracefully."""
    # Mock PIL Image.open to raise exception
    mock_image.open.side_effect = Exception("Cannot open image")
    
    result = perform_image_ocr(["/tmp/bad_image.png"])
    
    assert result == []  # Should handle error and return empty list
    mock_pytesseract.image_to_string.assert_not_called()


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_tesseract_error(mock_image, mock_pytesseract):
    """Test OCR handles tesseract errors gracefully."""
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    # Mock tesseract to raise exception
    mock_pytesseract.image_to_string.side_effect = Exception("Tesseract failed")
    
    result = perform_image_ocr(["/tmp/test.png"])
    
    assert result == []  # Should handle error and return empty list


@pytest.mark.unit
def test_perform_image_ocr_missing_dependencies():
    """Test OCR returns empty list when dependencies not available."""
    with patch('builtins.__import__', side_effect=lambda name, *args: ImportError("No pytesseract") if name == 'pytesseract' else __import__(name, *args)):
        result = perform_image_ocr(["/tmp/test.png"])
        assert result == []


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_metadata_completeness(mock_image, mock_pytesseract):
    """Test OCR chunk metadata includes all expected fields."""
    mock_img = Mock()
    mock_image.open.return_value.__enter__ = Mock(return_value=mock_img)
    mock_image.open.return_value.__exit__ = Mock(return_value=False)
    
    raw_text = "Original text with some noise\n+++++"
    cleaned_text = "Original text with some noise"
    mock_pytesseract.image_to_string.return_value = raw_text
    
    result = perform_image_ocr(["/tmp/doc_page7_img2.png"])
    
    assert len(result) == 1
    chunk = result[0]
    
    # Check all metadata fields
    metadata = chunk['metadata']
    assert metadata['type'] == 'image_ocr'
    assert metadata['source_image'] == "/tmp/doc_page7_img2.png"
    assert metadata['ocr_engine'] == 'tesseract'
    assert metadata['raw_length'] == len(raw_text)
    assert metadata['clean_length'] == len(cleaned_text)
    
    # Check chunk structure
    assert chunk['text'] == cleaned_text
    assert chunk['page_number'] == 7
    assert chunk['chunk_type'] == 'image_ocr'


@pytest.mark.unit
@patch('pytesseract')
@patch('PIL.Image')
def test_perform_image_ocr_empty_input(mock_image, mock_pytesseract):
    """Test OCR with empty image path list."""
    result = perform_image_ocr([])
    
    assert result == []
    mock_image.open.assert_not_called()
    mock_pytesseract.image_to_string.assert_not_called()